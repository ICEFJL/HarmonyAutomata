import { State } from '../datastructure/State';
import {BaseAutomaton} from '../datastructure/BaseAutomaton';
import {Transition} from '../datastructure/Transition';
import {Automaton} from '../datastructure/Automaton';
import { ToastUtil } from '@pura/harmony-utils';

export class AutomatonToRegexConverter {
  static convertToRegex(automaton: BaseAutomaton): string {
    const states = automaton.getStates();
    const transitions = automaton.getTransitions();
    const initialState = automaton.initialState;
    const finalStates = states.filter(s => s.isFinal);

    if (!initialState) {//||finalStates.length === 0
      ToastUtil.showToast("è½¬æ¢å¤±è´¥:è‡ªåŠ¨æœºå¿…é¡»æœ‰ä¸€ä¸ªåˆå§‹çŠ¶æ€");
      //throw new Error("è‡ªåŠ¨æœºå¿…é¡»æœ‰ä¸€ä¸ªåˆå§‹çŠ¶æ€å’Œè‡³å°‘ä¸€ä¸ªç»ˆæ­¢çŠ¶æ€");
      return "Error";
    }

    // Step 1: åˆå§‹åŒ–è½¬ç§»å›¾
    const transitionMap: Map<number, Map<number, string>> = new Map();
    for (const state of states) {
      transitionMap.set(state.uuid, new Map());
    }

    // åˆå¹¶åŒä¸€å¯¹ from -> to çš„æ ‡ç­¾ä¸ºæ­£åˆ™â€œæˆ–â€å…³ç³»
    for (const transition of transitions) {
      const fromMap = transitionMap.get(transition.from)!;
      const existing = fromMap.get(transition.to);
      const labels = existing ? new Set(existing.split("+")) : new Set<string>();

      for (const char of transition.label) {
        if (char) labels.add(char);  // é¿å…ç©ºå­—ç¬¦å‚ä¸åˆå¹¶
        else labels.add("Îµ");
      }

      const combined = Array.from(labels).join("+");
      const labelStr = labels.size > 1 ? `(${combined})` : combined;
      fromMap.set(transition.to, labelStr);
    }


    // Step 2: æ·»åŠ å”¯ä¸€ç»ˆæ€ (virtualFinal)ï¼Œå¹¶é€šè¿‡ Îµ è½¬ç§»è¿æ¥æ‰€æœ‰åŸç»ˆæ€
    const virtualFinal = new State(0, 0, "virtualFinal", true, Date.now());
    transitionMap.set(virtualFinal.uuid, new Map());
    // ğŸ‘‡ ç¡®ä¿æ¯ä¸ªç»ˆæ€éƒ½è¢«æ­£ç¡®è¿æ¥åˆ° virtualFinal
    for (const final of finalStates) {
      let finalMap = transitionMap.get(final.uuid);
      if (!finalMap) {
        finalMap = new Map();
        transitionMap.set(final.uuid, finalMap);
      }

      const existing = finalMap.get(virtualFinal.uuid);
      if (existing) {
        finalMap.set(virtualFinal.uuid, existing + "+Îµ");
      } else {
        finalMap.set(virtualFinal.uuid, "Îµ");
      }
    }
    /*for (const char of transition.label) {
      if (char) labels.add(char); } // é”™è¯¯ï¼šé€å­—ç¬¦å¤„ç†
}   */
    // å°† virtualFinal åŠ å…¥çŠ¶æ€é›†åˆ
    const allStates = [...states, virtualFinal];

    // Step 3: æ¶ˆé™¤é™¤ initial å’Œ virtualFinal å¤–çš„çŠ¶æ€
    for (const state of allStates) {
      if (state.uuid !== initialState.uuid && state.uuid !== virtualFinal.uuid) {
        AutomatonToRegexConverter.eliminateState(state.uuid, transitionMap);
      }
    }

    // Step 4: æå–æœ€ç»ˆæ­£åˆ™è¡¨è¾¾å¼
    let result = transitionMap.get(initialState.uuid)?.get(virtualFinal.uuid) || "";

    // ğŸ‘‡ è·å–åˆå§‹çŠ¶æ€çš„è‡ªç¯ï¼ˆloopï¼‰å¹¶è¡¥ä¸Šå¾ªç¯ç»“æ„
    const selfLoop = transitionMap.get(initialState.uuid)?.get(initialState.uuid);
    if (selfLoop) {
      const loopPart = selfLoop.length === 1 ? `${selfLoop}*` : `(${selfLoop})*`;
      result = loopPart + result;
    }

    // å¦‚ virtualFinal æœ‰è‡ªç¯ï¼ŒåŠ ä¸Šå¾ªç¯ï¼ˆä¸€èˆ¬ä¸ä¼šå‡ºç°ï¼Œä½†ä¿ç•™ï¼‰
    const finalLoop = transitionMap.get(virtualFinal.uuid)?.get(virtualFinal.uuid);
    if (finalLoop) {
      result = `(${result})(${finalLoop})*`;
    }
    // æ˜¾å¼åŒºåˆ†ç©ºè·¯å¾„ï¼ˆÎµï¼‰å’Œæ— è·¯å¾„ï¼ˆnullï¼‰
    const reachable = transitionMap.get(initialState.uuid)?.has(virtualFinal.uuid);
    if (!reachable) {
      return"<ä¸å¯è¾¾>";
    } else if (result == "") {
      return"Îµ";
    }
    console.log(" ç»“æœ: " +result);
    result=AutomatonToRegexConverter.simplify(result);
    result=AutomatonToRegexConverter.flattenUnions(result);
    console.log(" ç»“æœ2: " +result);
    console.log("Final regex candidates from initial to virtualFinal:");
    const mapToPrint = transitionMap.get(initialState.uuid);
    if (mapToPrint) {
      console.log("Initial state's outgoing transitions:");
      for (const key of mapToPrint.keys()) {
        const value = mapToPrint.get(key);
        console.log("  to state " + key + ": " + value);
      }
    }
    //console.log(" ç»“æœ: " +result);
    return AutomatonToRegexConverter.simplify(result);
  }

  private static eliminateState(stateId: number, transitionMap: Map<number, Map<number, string>>): void {
    let fromStates = Array.from(transitionMap.keys()).filter(from => transitionMap.get(from)?.has(stateId));
    let toStates = Array.from(transitionMap.get(stateId)?.keys() || []);
    let loop = transitionMap.get(stateId)?.get(stateId) || "";
    console.log(`æ¶ˆé™¤çŠ¶æ€ ${stateId}`);
    for (const from of fromStates) {
      for (const to of toStates) {
        if (from === stateId || to === stateId) continue;

        let fromToState = transitionMap.get(from)?.get(stateId) || "";
        let stateToTo = transitionMap.get(stateId)?.get(to) || "";
        let fromTo = transitionMap.get(from)?.get(to) || "";

        let newRegex = fromTo;
        if (fromToState && stateToTo) {
          let middle = loop ? `(${loop})*` : "";
          newRegex = fromTo ? `${fromTo}+(${fromToState}${middle}${stateToTo})` : `(${fromToState}${middle}${stateToTo})`;
        }

        // ç¡®ä¿ `to` çŠ¶æ€æœ‰è‡ªç¯æ—¶ï¼Œä¿ç•™å®ƒ
        let loopTo = transitionMap.get(to)?.get(to) || "";
        if (loopTo) {
          newRegex = `(${newRegex})(${loopTo})*`;
        }

        if (newRegex) {
          transitionMap.get(from)?.set(to, newRegex);
        }

      }
    }

    // åˆ é™¤è¯¥çŠ¶æ€çš„æ‰€æœ‰è®°å½•
    transitionMap.delete(stateId);
    for (const map of transitionMap.values()) {
      map.delete(stateId);
    }
  }

  public static simplify(regex: string): string {
    let simplified = regex;

    simplified = AutomatonToRegexConverter.removeRedundantParentheses(simplified);
    simplified = AutomatonToRegexConverter.simplifyEmptyStrings(simplified);
    simplified = AutomatonToRegexConverter.simplifyUnions(simplified);
    simplified = AutomatonToRegexConverter.factorizeUnionGroups(simplified);
    simplified = AutomatonToRegexConverter.simplifyConcatenations(simplified);
    //simplified = AutomatonToRegexConverter.removeRedundantParentheses(simplified);
    if (simplified.startsWith('(') && simplified.endsWith(')')) {
      simplified = simplified.slice(1, -1);
    }
    return simplified;
  }

  private static removeRedundantParentheses(regex: string): string {
    // åªå»é™¤â€œéæ“ä½œç¬¦åŒ…è£¹ä¸”ä¸å½±å“é‡è¯â€çš„å†—ä½™æ‹¬å·
    return regex.replace(/\(([^()+*?]+)\)(?![*+?])/g, '$1');
  }

  private static simplifyEmptyStrings(regex: string): string {
    // Îµa -> a, aÎµ -> aï¼Œä½†ä¿ç•™ Îµ+ æˆ– +Îµ å½¢å¼
    return regex
      .replace(/Îµ+/g, 'Îµ')
      .replace(/Îµ([a-zA-Z0-9(])/g, '$1')   // Îµa -> a
      .replace(/([a-zA-Z0-9)*])Îµ/g, '$1');   // aÎµ -> a
  }


  private static simplifyUnions(regex: string): string {
    // é€å­—ç¬¦æ‰«æï¼Œé¿å…å¤„ç†è¿æ¥å½¢å¼ï¼ˆä¾‹å¦‚ a+(a+b)cï¼‰
    let result = '';
    let buffer = '';
    let depth = 0;
    let i = 0;

    while (i < regex.length) {
      const char = regex[i];

      if (char === '(') {
        depth++;
        buffer += char;
      } else if (char === ')') {
        depth--;
        buffer += char;
      } else if (char === '+' && depth === 0) {
        // é¡¶å±‚å¹¶é›†å‘ç°ï¼Œç»“æŸå½“å‰é¡¹
        buffer += '|||'; // ç”¨ä¸´æ—¶åˆ†éš”ç¬¦æ ‡è®°å¹¶é›†æ‹†åˆ†ç‚¹
      } else {
        buffer += char;
      }

      i++;
    }

    // æŒ‰æˆ‘ä»¬æ’å…¥çš„ ||| æ‹†åˆ†å¹¶å»é‡
    const terms = buffer.split('|||').map(t => t.trim());
    const unique = Array.from(new Set(terms));
    result = unique.join('+');

    // è‹¥å¤šé¡¹ï¼Œç”¨æ‹¬å·åŒ…è£¹
    if (unique.length > 1) {
      result = `(${result})`;
    }

    return result;
  }

  private static simplifyConcatenations(regex: string): string {
    // åˆ é™¤ä»…åŒ…å›´å•ä¸ªå­—ç¬¦çš„æ‹¬å·ï¼š (a) â†’ a
    regex = regex.replace(/\(([a-zA-Z0-9])\)/g, '$1');

    // åˆ é™¤é‡å¤æ‹¬å·ï¼š ((a)) â†’ (a)
    regex = regex.replace(/\(\((.*?)\)\)/g, '($1)');

    // åˆå¹¶æ˜¾å¼æ‹¼æ¥ï¼ša(b) â†’ ab, (a)b â†’ ab, (a)(b) â†’ ab
    regex = regex.replace(/([a-zA-Z0-9])\(([^+()]+)\)/g, '$1$2'); // a(b) â†’ ab
    regex = regex.replace(/\(([^+()]+)\)([a-zA-Z0-9])/g, '$1$2'); // (a)b â†’ ab
    regex = regex.replace(/\(([^+()]+)\)\(([^+()]+)\)/g, '$1$2'); // (a)(b) â†’ ab

    return regex;
  }

  private static factorizeUnionGroups(regex: string): string {
    // åŒ¹é…å½¢å¦‚ xa+ya â†’ (x+y)a
    return regex.replace(/([a-zA-Z]+)a\+([a-zA-Z]+)a/g, (match:string, p1:string, p2:string) => {
      if (p1 !== p2) {
        return `(${p1}+${p2})a`;
      }
      return match;
    }).replace(/a([a-zA-Z]+)\+a([a-zA-Z]+)/g, (match:string, s1:string, s2:string) => {
      if (s1 !== s2) {
        return `a(${s1}+${s2})`;
      }
      return match;
    });
  }

  // å¤„ç† a+(a+b) => a+bã€(a+b)+a => a+bã€(a+b)+(b+c) => a+b+c
  private static flattenUnions(regex: string): string {
    const unionGroups = regex.split('+');
    const terms = new Set<string>();

    for (let term of unionGroups) {
      // å»é™¤æ‹¬å·ï¼Œä¾‹å¦‚ (a+b) â†’ a+b
      if (term.startsWith('(') && term.endsWith(')')) {
        term = term.slice(1, -1);
      }
      // å†æ¬¡åˆ†å‰²å¯èƒ½å­˜åœ¨çš„å­ +
      for (const sub of term.split('+')) {
        terms.add(sub);
      }
    }

    return Array.from(terms).sort().join('+');
  }

}
